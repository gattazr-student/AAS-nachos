\documentclass[a4paper,10pt]{article}

% Encodage and langue
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}

% Redéfinition des marges
\usepackage[top=2cm, bottom=2cm, left=2.0cm, right=2cm]{geometry}

% Package pour insertion de code
\usepackage{listings} % Insertion de code
\usepackage{lstautogobble} % Autogobble
\usepackage{graphicx} % insertion d'images
% \usepackage{float} % Placement d'éléments
\usepackage[dvipsnames]{xcolor} % colors
\usepackage{url} % Insertion d'url url

% \usepackage{amsfonts} % pour utiliser les symboles de ensembles (reel...autre)
% \usepackage{amsmath} %debut des package pour utiliser les formules de math
% \usepackage{amssymb}
% \usepackage{mathrsfs}
%\usepackage{wrapfig}


% Listing config
\lstset{
    language=C++,
    basicstyle=\normalsize, % ou ça==> basicstyle=\scriptsize,
    % upquote=true,
    autogobble,
    frame=single,
    aboveskip={1.5\baselineskip},
    columns=fullflexible,
    showstringspaces=false,
    extendedchars=true,
    breaklines=true,
    showtabs=false,
    showspaces=false,
    showstringspaces=false,
    identifierstyle=\ttfamily,
    keywordstyle=\color[rgb]{0,0,1},
    commentstyle=\color[rgb]{0.133,0.545,0.133},
    stringstyle=\color[rgb]{0.627,0.126,0.941},
}

\setlength\parindent{0pt}
\setlength{\parskip}{1em}

\title{Step 5 : NachOS et la gestion des fichiers}
\author{Tanguy MATHIEU, Florian POPEK, Rémi GATTAZ, Jordan ELLAPIN}


\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Objectifs}
    Au cours de cette étape, nous avons eu commencer à manipuler le système de fichiers de NachOS.
    Nous avions les objectifs suivant :
    \begin{itemize}
        \item Mettre en place une hierarchie de dossier dans le fyle système
        \item Augmenter la taille maximum des fichierss
    \end{itemize}
    \vspace{0.8em}
    Chacun de ces objectifs va être détaillé dans une partie.


\section{Hierarchie de dossier}
    Nachos founis à travers la classe FileSytem un système de fichier. D'origine, ce système est
    cependant à un seul niveau. C'est à dire que tous les fichiers se trouvent dans un unique
    dossier, le dossier racine.

    Le but de cet objectif est d'étendre ce système de fichier afin de pouvoir créer et supprimer
    des dossiers et de naviguer dans le système de fichier.

    \subsection{Fichier et Dossier}
        Dans le monde Unix, le filesystem ne contient que des fichiers qui sont tous décris
        à l'aide de structures appelé inode. Dans NachOS, cette structure est représenté par
        la classe FileHeader mais ici aussi, le système de fichier n'utilise que des fichiers.

        Le type du fichier, doit donc pouvoir être déterminé grace à la classe FileHeader. Puisque
        nous n'allons gérer que des fichiers normaux ou des dossiers, nous avons opté pour ajouter
        uniquement la fonction \textit{isDir()}. Un fichier sera alors distingué d'un dossier gràce
        à l'attribut privé de la classe \textit{numBytes}. Si cette valeur a été initiliasé
        négative, cela signifiera que le header décrit un dossier. Sinon, c'est qu'il s'agit d'un
        fichier.

        \begin{lstlisting}
            bool isDir(){ return (numBytes < 0); }
        \end{lstlisting}

    \subsection{Hierarchie}
        Un dossier est stocké comme un fichier sur le disque. Le contenu de ce fichier n'est
        cependant des données mais l'ensemble des secteurs du disque qui contiennet les Fileheaders que le dossier contient.

        En considérant qu'un FileHeader peut être la description d'un autre dossier, selon
        l'architecture actuelle, il est possible de descendre dans une hierarchie de dossier de
        dossier. Mais il n'existe encore aucun moyen pour remonter dans cette hierarchie. Pour
        pouvoir faire cela, nous avons besoin de rajouter la notion de \textit{parent} à un dossier.
        Ainsi, il sera toujours possible de remonter au dossier supérieur.

        Pour faire cela, nous avons modifié le constructeur de la class Directory.
        \begin{lstlisting}
            Directory::Directory(int size, int sector=1, int parent=1)
        \end{lstlisting}

        Ce nouveau constructeur nous permet de définir à la création d'un objet Directory ou se
        trouve le dossier parent sur le disque et ou va se trouve le nouveau dossier. Ceci nous permet alors de créer deux entrées par défault dans le dossier. Les entrés \textit{.} et
        \textit{..} correspondant respectivement aux entrées \textit{dossier courant} et
        \textit{dossier parent}.

        \begin{lstlisting}
            Add(".", sector);
            Add("..", parent);
        \end{lstlisting}

        Ces deux entrés vont nous permettre de toujours pouvoir déterminer ou se trouve le dossier
        parent du dossier courant. Pour le dossier racine, qui n'a par définition pas de dossier
        parent, il a été décidé que son dossier parent serait lui même.


    \subsection{Creation de dossier}
        Créer un dossier est pratiquement la même chose que créer un fichier. La fonction
        \textit{} que nous avons créer est donc très proche de celle ci.

        \begin{lstlisting}
            bool FileSystem::CreateDirectory(char* dirName){
                Directory *directory;
                BitMap *freeMap;
                FileHeader *hdr;
                int sector;
                bool success;

                DEBUG('f', "Creating directory %s\n", dirName);

                directory = new Directory(NumDirEntries);
                directory->FetchFrom(directoryFile);

                if (directory->Find(dirName) != -1){
                    success = FALSE; // file is already in directory
                } else {
                    freeMap = new BitMap(NumSectors);
                    freeMap->FetchFrom(freeMapFile);
                    sector = freeMap->Find();	// find a sector to hold the file header

                    if (sector == -1){
                        success = FALSE;		// no free block for file header
                    }else if (!directory->Add(dirName, sector))
                        success = FALSE;	// no space in directory
                    else {
                        hdr = new FileHeader;
                        if (!hdr->Allocate(freeMap, -1*DirectoryFileSize)){
                            success = FALSE;	// no space on disk for data
                        }else {
                            success = TRUE;
                            // everthing worked, flush all changes back to disk
                            hdr->WriteBack(sector);
                            // Create directory
                            Directory *dir = new Directory(NumDirEntries, sector, directory->Find("."));
                            dir->WriteBack(new OpenFile(sector));
                            directory->WriteBack(directoryFile);
                            freeMap->WriteBack(freeMapFile);
                            delete dir;
                        }
                        delete hdr;
                    }
                    delete freeMap;
                }
                delete directory;
                return success;
            }
        \end{lstlisting}

    \subsection{Déplacement dans un dossier}
        Toute les fonctions de la classe FileSystem sont exécuté selon un dossier courant. Ce
        dossier est determiné selon la valeur de l'attribut privé \textit{directoryFile} de la
        classe FileSystem.

        Nous déplacer dans le FileSystem va donc revenir à modifier cette variable.
        \begin{lstlisting}
            bool FileSystem::ChangeDirectory(char* dirName){
                // Retrieve parent Dir
                OpenFile *parentDirFile = directoryFile;
                Directory *parentDir = new Directory(NumDirEntries);
                parentDir->FetchFrom(parentDirFile);

                // Look for directory dirName
                int dirHeaderSector = parentDir->Find(dirName);
                if(dirHeaderSector == -1){
                    printf("ChangeDirectory: directory %s does not exist\n", dirName);
                    delete parentDir;
                    return FALSE;
                }
                // Create OpenFile FileHeader
                FileHeader* targetHdr = new FileHeader();
                targetHdr->FetchFrom(dirHeaderSector);

                // Test if is a directory
                if(targetHdr->isDir() == 0){
                    printf("ChangeDirectory: %s is not a directory\n", dirName);
                    delete targetHdr;
                    delete parentDir;
                    return FALSE;
                }

                // Replace directoryFile
                delete directoryFile;
                directoryFile = new OpenFile(dirHeaderSector);

                delete targetHdr;
                delete parentDir;
                return TRUE;
            }
        \end{lstlisting}

    \newpage
    \subsection{Creation de commandes}
        Afin de tester les fonctions \textit{ChangeDirectory} et \textit{CreateDirectory}, nous
        avons créé des paramètres suplémentaires au programme. Pour faire cela, nous avons
        rajouté le traitement suivant dans la gestion des paramètres suivants.
        \begin{lstlisting}
            else if (!strcmp (*argv, "-mkdir")) {
                ASSERT (argc > 1);
                fileSystem->CreateDirectory (*(argv + 1));
            } else if (!strcmp (*argv, "-cd")) {
                ASSERT (argc > 1);
                fileSystem->ChangeDirectory(*(argv + 1));
            }
        \end{lstlisting}



        Voici un exemple d'une commande exécutable :
        \begin{lstlisting}
            $ ./nachos-filesys -f -mkdir folder -l -cd folder -mkdir subFolder -l
        \end{lstlisting}
        Cette commande fait les opéraitons suivantes :
        \begin{itemize}
            \item Formatage du système de fichier
            \item Création du dossier dir dans le dossier \textit{root}
            \item Liste le contenu du dossier courant (\textit{root})
            \item Changement du dossier courant en le dossier \textit{folder}
            \item Création du dossier \textit{subFolder} dans le dossier courant
            \item Liste le contenu du dossier courant (\textit{subFolder})
        \end{itemize}

% \section{Taille maximum des fichiers}
%     Dans la partie précédente, il a été abrodé que les fichiers sont découpés sur le disque et
%     stocké dans des secteurs disques qui sont référencés dans un FileHeader. De base, NachOS
%     n'utilise que les 10 secteurs références de façons directe dans le FileHeader. De ce fait,
%     la taille des fichiers et des dossier est limités à la taille de 10 secteurs disques.
%
%     Le but de cet objectif etait alors d'augmenter cette taille maximum.
%
%
%     N'ayant pas commencé l'implémentation de cette objectif, nous n'avons pas


\end{document}
